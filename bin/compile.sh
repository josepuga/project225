#!/usr/bin/env bash
# Compiles de zig source and generates the override.mk for the builder toolchain
# Project225. By Jos√© Puga 2026
set -euo pipefail

zig_file="$1"

[ ! -f "$1" ] && {
    echo "Source file $1 not found"
    exit 1
}

zig_file=$(basename "$1")
obj_file="${zig_file%.*}.o"
module_name="${zig_file%.*}"
src_dir=$(dirname "$1")
common_modules_path="../_common_modules"
src_dir=$(realpath "$src_dir")

cd "$(dirname "$0")"/..
out_path=$(realpath kernel-shared/zig)

[ ! -d "$out_path" ] && {
    echo "Directory $out_path not found. Did you mount the kernel-shared?" 
    exit 1
}

cd "$src_dir"

[ $# -eq 0 ] && {
    echo "This script compiles a single zig file and creates the .o file"
    echo "in $out_path"
    echo 
    echo "Usage: $0 <zig file>"
    exit 1
}

[ ! -d "$out_path" ] && {
    echo "Output path $out_path. Does not exists"
    echo "  - Be sure builder VM is running."
    echo "  - Check if kernel-shared/ is mounted."
    exit 1
}


# Common modules (no extension)
mapfile -t common_modules < <(
    find "$common_modules_path" -maxdepth 1 -name '*.zig' -printf '%f\n' | \
    sed 's/\.zig$//' | sort
)

echo "Generating build.zig..."

#
# BEGIN create build.zig
#
build_file="$src_dir/build.zig"

cat > "$build_file" <<EOF
///! Creates the object file with ABI compatible with kernel 2.2.5
// Autogenerated file for Project225

const std = @import("std");

pub fn build(b: *std.Build) void {
    // These options are required to generate an ABI compatible.
    const target = b.resolveTargetQuery(.{
        .cpu_arch = .x86,
        .os_tag = .freestanding,
        .abi = .none,
    });
    const optimize = .ReleaseSmall;

    // Root module. This is our "main zig"
    const root_mod = b.createModule(.{
        .root_source_file = b.path("$zig_file"),
        .target = target,
        .optimize = optimize,
    });
EOF

# Add commons modules
cat >> "$build_file" <<EOF
    // Common general-purpose modules
    // --- BEGIN common modules
EOF
for mod in "${common_modules[@]}"; do
    file_name="${mod%}.zig"
    cat >> "$build_file" <<EOF
    const ${mod}_mod = b.createModule(.{
        .root_source_file = b.path("$common_modules_path/$file_name"),
        .target = target,
        .optimize = optimize,
    });
    // This allow use the module without extension, like system ones.
    root_mod.addImport("$mod", ${mod}_mod);
EOF
done

cat >> "$build_file" <<EOF
    // --- END common modules

    const obj = b.addObject(.{
        .name = "$module_name",
        .root_module = root_mod,
    });

    // Copy output
    //const out_path = "$obj_file";    

    // Default output to zig-out/. Another path can be forced
    // with zig build --prefix path
    const install_file = b.addInstallFile(
        obj.getEmittedBin(),
        "$obj_file",
    );

    const build_step = b.step("build", "Build object");
    build_step.dependOn(&install_file.step);
    b.default_step = build_step;
}
EOF
#
# END create build.zig
#

# Compile process
echo "Compiling $obj_file..."
cd "$src_dir"
zig build --prefix "$out_path"
echo "Cleaning..."
rm -fr "$src_dir/.zig-cache/"
echo
echo "$out_path/$obj_file created!"
echo
echo "Generating $out_path/override.mk"
"$(dirname "$0")"/gen-override.py
echo
nm "$out_path/$obj_file"